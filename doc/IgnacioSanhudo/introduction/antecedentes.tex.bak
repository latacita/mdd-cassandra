%%==================================================================%%
%% Author : Sañudo Olmedo, Ignacio                                  %%
%%          Sánchez Barreiro, Pablo                                 %%
%% Version: 1.3, 18/06/2013                                         %%                                                                                    %%                                                                  %%
%% Memoria del Proyecto Fin de Carrera                              %%
%% Introduccion/Antecedentes MDE-MDD                                %%
%%==================================================================%%

Según [2] la Ingeniería Dirigida por Modelos o MDE puede ser definida como la \emph{"técnica que hace uso, de forma sistemática y reiterada, de modelos como elementos primordiales a largo de todo el proceso de desarrollo. MDE trabaja con modelos como entradas al proceso y produce modelos como salidas del mismo"}. El concepto de Desarrollo Dirigido por Modelos (MDD) es como se puede observar en la (Figura~\ref{back:fig:MDA}, etiqueta 1). un subconjunto de la Ingeniería Dirigida por Modelos (MDE). A diferencia de MDD,[3] MDE va más allá de las actividades de desarrollo de puros y abarca otras tareas basadas en el proceso de modelado por ejemplo, aplicar ingeniería inversa a un modelo.

\begin{figure}[!tb]
  \centering
  \includegraphics[width=.70\linewidth]{background/images/MDAMDDMDEMBE.eps} \\
  \caption{Capas del modelado de lenguajes}
  \label{back:fig:MDA}
\end{figure}

Tanto la Ingeniería Dirigida por Modelos como el Desarrollo Dirigido por Modelos aportan varias ventajas respecto a métodos de desarrollo tradicionales, entre estos podemos encontrar las siguientes ventajas [4]:
\begin{enumerate}
\item Tiempo de desarrollo menor: Esto se puede interpretar de la siguiente manera. Al trabajar con modelos lo único que hace falta desarrollar es el generador de código por lo que el tiempo de desarrollo a tener en cuenta es el dedicado al generador de código.
\item Reutilización de componentes en distintos sistemas debido a que trabajamos con modelos.
\item Si se centran los esfuerzos en el generador de código se puede mejorar  la calidad del software, además reducimos la cantidad de errores así como el tiempo incurrido en testeos.
\item Eleva el nivel de abstracción pues los problemas que se trabajan son cercanos al dominio del problema.
\end{enumerate}

Otros beneficios que se pueden dar utilizando MDD son descritos por [5] en el ámbito de los repositorios institucionales, los beneficios más importantes que se pueden extrapolar a otras áreas son los siguientes:
\begin{enumerate}
\item Un menor número de líneas de código escritas, ya que los niveles de abstracción de MDD a través de los modelos y meta-modelos diseñados fomentan el reusó del código y de los modelos.
\item Alto nivel de abstracción para escribir aplicaciones y artefactos de software a través de la arquitectura de niveles del meta-modelado y las capas de modelado de MDD. Este beneficio favorece diseñar una aplicación partiendo de lo mas general a lo más concreto, es decir, son independientes de la tecnología.
\item Especificación de requisitos de usuario a varios niveles obteniendo un sistema flexible a los cambios.
\end{enumerate}

Una vez entendidos los conceptos anteriores y los beneficios que nos proporciona este enfoque de desarrollo se presentan los conceptos básicos que nos ayudaran a comprender como funciona MDD.

El enfoque del Desarrollo Dirigido por Modelos parte del metamodelo [6], el cual es la representación del sistema en sintaxis abstracta.
Un lenguaje de modelado está formado de sintaxis y semántica. La sintaxis son el conjunto de normas o reglas de escritura del lenguaje. La semántica refleja el significado de la sintaxis.

La definición de la sintaxis abstracta es el primer paso en el proceso de diseño de un lenguaje. Especifica la forma del metamodelo. Clases y relaciones de dominio son los principales elementos que forman parte de un metamodelo.
Los metamodelos son considerados instancias de estos lenguajes de modelado. Un ejemplo de metamodelo es la definición de UML [7]. En UML por ejemplo el concepto de clase, paquete o atributo son elementos que se pueden usar en UML.

La definición de la sintaxis concreta es el siguiente paso, este paso consiste en la representación de los elementos bien definidos en la sintaxis abstracta. Véase la creación de un modelo. Un modelo es la representación concreta de los elementos descritos en la sintaxis abstracta o metamodelo. Por lo tanto un modelo siempre posee las propiedades y cumple las restricciones de su metamodelo. En la (Figura~\ref{back:fig:ejALL}, etiqueta 2) se pueden observar representaciones de los elementos descritos.

\begin{figure}[!tb]
  \centering
  \includegraphics[width=1.1\linewidth]{background/images/ejALL.eps} \\
  \caption{(a) Metamodelo, (b) Sintaxis concreta, (c) Sintaxis grafica}
  \label{back:fig:ejALL}
\end{figure}

Según [6] estos son los pasos que hay que realizar para la creación de un nuevo lenguaje de modelado:
\begin{enumerate}
\item En primer lugar hay que establecer cuál va a ser la sintaxis de nuestro lenguaje de modelado. Para ello hay que crear un metamodelo el cual como se comentaba anteriormente establece cuales son las reglas que han de seguir los modelos.  El metamodelo ha de ser construido utilizando un lenguaje de metamodelado, el lenguaje de modelado utilizado en el presente proyecto es ECore [8]. Además de ECore hay otros lenguajes de modelado como puede ser MOF [9].
\item El siguiente paso consiste en la definición de la sintaxis concreta de nuestro lenguaje de modelado. La creación de un modelo bien definido a partir del metamodelo creado en el paso anterior.
\item La definición de la semántica del lenguaje de modelado es el último paso, por ejemplo crear un generador que transforme los elementos del modelo en elementos de un lenguaje distinto bien definido.
\end{enumerate}

La herramienta con la que se va a trabajar es EMF un plugin de eclipse que nos permite crear y trabajar con lenguajes de modelado.
MDE proporciona las transformaciones de modelos como principal herramienta para trabajar con modelos en el proceso de desarrollo software.
\begin{enumerate}
\item \emph{Model to model (M2M)}. Dado un modelo de entrada esta transformación produce otro modelo como salida. Este tipo de transformación se puede utilizar de varias formas, la primera transformar un modelo dándole propiedades que no posee el original. La segunda es la que se utilizara en el presente proyecto, dado un modelo origen en UML realizar una transformación a un modelo destino escrito en Cassandra (Figura~\ref{back:fig:transformacion}, etiqueta 3). Esta información es ampliada en el siguiente capítulo.

\item \emph{Model to text (M2T)}. Es la ultima transformación que se realiza en la etapa de desarrollo para generar el código de la aplicación. Estas transformaciones no generan un modelo de salida si no una representación textual del modelo que se desea transformar. Se puede utilizar para generar por ejemplo una representación del modelo transformado en formato HTML.
\end{enumerate}

\begin{figure}[!tb]
  \centering
  \includegraphics[width=1.05\linewidth]{background/images/transformacion.eps} \\
  \caption{Proceso de transformación de un modelo}
  \label{back:fig:transformacion}
\end{figure}

Para explicar todo este proceso se presenta un sencillo ejemplo donde se explican cómo se utilizan brevemente las técnicas de desarrollo dirigido por modelos, Model to Model (M2M) y Model to Text (M2T). Para aplicar M2M nos harán falta dos metamodelos (uno origen y uno destino) y para aplicar M2T se ha diseñado un sencillo generador de código HTML.

La (Figura~\ref{back:fig:grafoMetamodelo}, etiqueta 4) muestra la representación de la sintaxis abstracta o metamodelo del lenguaje. El metamodelo consiste en un sencillo grafo el cual está compuesto de un número indefinido de nodos los cuales están conectados entre sí mediante aristas. Estos nodos como se ve en la imagen tienen un atributo de tipo "Tcolor" por lo que un Nodo puede ser de color rojo o de color azul. Por lo tanto un modelo bien definido de este metamodelo será un modelo que contenga un grafo con un numero cualquiera de Nodos conectados dos a dos entre sí mediante aristas.

\begin{figure}[!tb]
  \centering
  \includegraphics[width=.8\linewidth]{background/images/grafoMetamodelo.eps} \\
  \caption{Metamodelo de un grafo}
  \label{back:fig:grafoMetamodelo}
\end{figure}

A continuación se presenta otro metamodelo como se ve en la (Figura~\ref{back:fig:metamodeloRed}, etiqueta 5). Este metamodelo consiste en la representación de una red de computadores que está compuesta de PC's y Routers estos análogamente al anterior metamodelo están conectados indistintamente entre sí mediante cables. Tanto los nodos como los cables tiene un atributo de tipo "String" para definir el nombre.

\begin{figure}[!tb]
  \centering
  \includegraphics[width=.8\linewidth]{background/images/metamodeloRed.eps} \\
  \caption{Metamodelo de una red}
  \label{back:fig:metamodeloRed}
\end{figure}

Nuestro objetivo es la transformación de un modelo de tipo Grafo a un modelo de tipo Red, dependiendo del color del Nodo el Nodo será transformado en un PC o en un Router (Rojo-PC, Azul-Router) para realizar esta transformación se utilizan técnicas M2M.

Una vez obtenido el modelo de tipo Red deseamos representar textualmente el modelo generado para ello utilizamos técnicas M2T. En este caso la representación del modelo es realizada en formato HTML. La representación del código generado utilizando un modelo de tipo grafo y aplicando la transformación entre modelos es el que se puede observar en la (Figura~\ref{back:fig:ejGeneradorHTML}, etiqueta 6).

\begin{figure}[!tb]
  \centering
  \includegraphics[width=.8\linewidth]{background/images/ejGeneradorHTML.eps} \\
  \caption{Resultado transformación HTML}
  \label{back:fig:ejGeneradorHTML}
\end{figure}

El proceso que se ha seguido es explicado más detalladamente en capítulos posteriores, tanto las técnicas de transformación de modelos como la realización del generador de código así como la creación de los modelos.



