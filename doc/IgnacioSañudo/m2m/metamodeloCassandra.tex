%%==========================================================================%%
%% Author : Sañudo Olmedo, Ignacio                                          %%
%% Author : Sánchez Barreiro, Pablo                                         %%
%% Version: 1.2, 23/04/2014                                                 %%
%%                                                                          %%
%% Memoria del Proyecto Fin de Carrera                                      %%
%% M2M/MetamodeloCassandra                                                  %%
%%==========================================================================%%
Como habíamos descrito en el capitulo anterior la base del proceso de transformación entre modelos
parte del metamodelo. El metamodelo utilizado de UML en este proyecto es el que nos proporciona Epsilon, dicho metamodelo sigue el estándar de UML 2.0. Sin embargo nos hace falta un metamodelo que defina el lenguaje de Cassandra. Dicho metamodelo fue proporcionado por Pablo Sánchez Barreiro. El metamodelo sufrió algunos cambios respecto al inicial debido a exigencias del proyecto. El metamodelo de Cassandra es el que se ve en la figura Figura~\ref{back:fig:metamodeloCassandra}.

\begin{figure}[!tb]
  \centering
  \includegraphics[width=.8\linewidth]{m2m/images/ecoreDiag.eps} \\
  \caption{Metamodelo Cassandra}
  \label{back:fig:metamodeloCassandra}
\end{figure} 

El eje central del metamodelo es el KeySpace, el KeySpace es el equivalente a la base de datos en el modelo relacional, la clase del metamodelo KeySpace cuenta con los atributos: nombre utilizado para denominar el KeySpace, [cassandra] replicationFactor número de servidores de Cassandra de los que se debe guardar un registro u obtener una respuesta al recuperar algún registro y replicaPlacementStrategy que es la estrategia de replicación que se va a tomar, estrategias tenemos tres tipos: %[http://www.datastax.com/docs/1.0/cluster_architecture/replication]:
SimpleStrategy: Esta estrategia es la estrategia de replicación utilizada por defecto al crear un KeySpace utilizando Cassandra. Es utilizada para clústeres de data centers simples.
NetworkTopologyStrategy: Utilizada cuando se tiene (o se va a tener) el clúster desplegado a través de múltiples data centers. Esta estrategia especifica cuántas réplicas se desean en cada data center.
OldNetworkTopologyStrategy: Se utiliza para proporcionar retro compatibilidad con instalaciones Cassandra antiguas.

A continuación tenemos la clase ColumnFamily equivalente a las tablas en el modelo relacional, dentro de las CF encontramos dos tipos: las StaticColumnFamily y las DynamicColumnFamily. Recordamos que la CF estática es el equivalente a la tabla en el modelo relacional, sin embargo la CF dinámica es utilizada para la recuperación de datos eficiente, algo similar a las vistas del modelo relacional. %[http://www.datastax.com/docs/1.1/ddl/column_family#dynamic-column-families]. 
En CQL el orden de definición de las claves importa, en la primera columna se define la Partition Key esta tiene la propiedad de que todas las filas que comparten la misma Partition Key se almacenan en el mismo nodo físico %[http://www.datastax.com/docs/1.1/ddl/indexes].
Además, la inserción, actualización o eliminación de filas que comparten la Partition Key para una CF determinada se realizan de forma atómica. Es posible tener una Partition Key compuesta, es decir, una Partition Key formada por varias columnas, en CQL esto se define utilizando paréntesis para delimitar el conjunto de partición.
Dentro de las ColumnFamily encontramos Columns estos son los valores que se almacenan en las Column Families las cuales tienen el nombre como atributo y un tipo de dato. Dentro de los tipos encontramos dos clases, PrimitiveType y DataStructureType, el primero define los tipos primitivos, por ejemplo entero, texto, uuid, etc..
DataStructureType define las colecciones, estas pueden ser de dos tipos MapType o bien CollectionType, ambas  tiene un atributo llamado KeyType para definir el tipo primitivo que las caracteriza. MapType cuenta con un atributo llamado baseType de tipo primitivo que define el segundo tipo de dato del mapa. Dentro de CollectionType encontramos un atributo llamado kind que define el tipo de colección que vamos a utilizar esta puede ser o bien tipo set o tipo list. Más adelante se explica que características reúne cada colección y mapa y cuando se utilizan.
