%%==========================================================================%%
%% Author : Sañudo Olmedo, Ignacio                                          %%
%% Author : Sánchez Barreiro, Pablo                                         %%
%% Version: 1.2, 23/04/2014                                                 %%
%%                                                                          %%
%% Memoria del Proyecto Fin de Carrera                                      %%
%% M2M/MetamodeloCassandra                                                  %%
%%==========================================================================%%

Como habíamos descrito en el capitulo anterior la base del proceso de transformación entre modelos parte del meta-modelo. Previo paso a la definición de las reglas de transformación entre modelos necesitamos definir un meta-modelo de origen y un meta-modelo de destino. El meta-modelo de UML 2.0 utilizado en este proyecto como origen de la transformación es el que nos proporciona Epsilon, dicho meta-modelo sigue el estándar de UML 2.0. A parte del meta-modelo de UML nos hace falta un meta-modelo que defina el lenguaje de modelado de Cassandra. Dicho meta-modelo fue proporcionado por \imp{Pablo Sánchez Barreiro}. Este meta-modelo se construyo por medio de la abstracción de las principales características de Cassandra. El meta-modelo sufrió algunos cambios respecto al inicial debido a exigencias y variantes que sufrió el proyecto. La Figura~\ref{back:fig:metamodeloCassandra} muestra como se ha definido el lenguaje de modelado de Cassandra con EMF, como vemos se puede diseñar un lenguaje de manera muy similar a la definición de clases en UML. Este tipo de modelo es el origen del proceso de transformaciones entre modelos que queremos crear. A continuación se detallan los aspectos más importantes del meta-modelo de Cassandra.

\begin{figure}[!tb]
  \centering
  \includegraphics[width=.8\linewidth]{m2m/images/ecoreDiag.eps} \\
  \caption{Metamodelo Cassandra}
  \label{back:fig:metamodeloCassandra}
\end{figure}

De acuerdo con la arquitectura de Cassandra\footnote{\url{http://www.datastax.com/docs/1.0/cluster_architecture/replication/}}, el elemento raíz de cualquier esquema orientado a columnas es el keyspace, el keyspace es el equivalente a una base de datos en el modelo relacional, la meta-clase keyspace cuenta con los meta-atributos: nombre utilizado para denominar el keyspace, (\cite{diego:2012}) \imp{replicationFactor} que representa el número de servidores de Cassandra de los que se debe guardar un registro u obtener una respuesta al recuperar algún registro y \imp{replicaPlacementStrategy} es la estrategia de replicación que se va a tomar, dentro de estas estrategias de replicación encontramos tres tipos (\cite{cass:2014}): %[http://www.datastax.com/docs/1.0/cluster_architecture/replication]:

\begin{enumerate}
\item \emph{SimpleStrategy}: Es la estrategia de replicación utilizada por defecto al crear un keyspace utilizando Cassandra. Es utilizada para clústeres de datacenters simples.
\item \emph{NetworkTopologyStrategy}: Utilizada cuando el clúster es desplegado a través de múltiples data centers. Esta estrategia especifica cuántas réplicas se desean en cada data center.
\item \emph{OldNetworkTopologyStrategy}: Se utiliza para proporcionar retro-compatibilidad con instalaciones de Cassandra antiguas.
\end{enumerate}

A continuación tenemos la meta-clase \imp{ColumnFamily} equivalente a las tablas en el modelo relacional, dentro de esta meta-clase encontramos dos tipos: las \imp{StaticColumnFamily} y las \imp{DynamicColumnFamily}. Recordamos que las static column family son el equivalente a las tablas en el modelo relacional, sin embargo las dynamic column family son utilizadas para la recuperación de datos eficiente, algo similar a las vistas del modelo relacional\footnote{\url{http://www.datastax.com/docs/1.1/ddl/column_family#dynamic-column-families}}. %[http://www.datastax.com/docs/1.1/ddl/column_family#dynamic-column-families].

En cuanto a la definición de la primary key, las column families estáticas siguen una definición de claves clásica por lo que en el meta-modelo no se refleja, sin embargo las column families dinámicas tienen una definición de la primary key especial. A la hora de definir esta primary key hay que tener en cuenta el orden, en CQL el orden de definición de las claves importa, en la primera columna de la primary key se define la partition key, esta tiene la propiedad de que todas las filas que comparten la misma partition key se almacenan en el mismo nodo físico\footnote{http://www.datastax.com/docs/1.1/ddl/indexes}. %[http://www.datastax.com/docs/1.1/ddl/indexes].
Además, la inserción, actualización o eliminación de filas que comparten la partition key para una column family determinada se realizan de forma atómica. Es posible tener una partition key compuesta, es decir, una partition key formada por varias columnas, en CQL esto se define utilizando paréntesis para delimitar el conjunto de partición. En la siguiente columna se define la clustering key utilizada para la recuperación de filas de manera eficiente. En el meta-modelo solo tendremos en cuenta las partition key puesto que las columnas que no son definidas como partition key se toman como cluster key.
Aunque en siguientes secciones esta información se amplia, el resumen de la definición de column families dinámicas es la siguiente: \imp{PRIMARY KEY((partitioning key\_1, ... partitioning key\_n), clustering key\_1 ... clustering key\_n)}.


La siguiente meta-clase es \imp{Column}, esta meta-clase contiene los valores que se almacenan en las column families, estas columns tienen como meta-atributos el nombre y un tipo de dato.
Dentro de los tipos de datos que pueden darse en una columna encontramos dos meta-tipos, \imp{PrimitiveType} y \imp{DataStructureType}.
\imp{PrimitiveType} define los tipos primitivos, por ejemplo entero, texto, uuid, etc..
\imp{DataStructureType} define las colecciones. Estas colecciones pueden ser de dos tipos: \imp{MapType} o bien \imp{CollectionType}, ambas colecciones tienen un meta-atributo llamado \imp{KeyType} para definir el tipo primitivo que utilizan. \imp{MapType} cuenta con un meta-atributo llamado \imp{baseType} de tipo primitivo que define el segundo tipo de dato del mapa. Dentro de \imp{CollectionType} encontramos un meta-atributo llamado \imp{kind} que define el tipo de colección que vamos a utilizar, esta puede ser o bien tipo \imp{set} o tipo \imp{list}. Más adelante se explica que características reúne cada colección y mapa y cuando se utilizan.
