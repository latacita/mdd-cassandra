%%==================================================================%%
%% Author : Sañudo Olmedo, Ignacio                                  %%
%% Author : Sánchez Barreiro, Pablo                                 %%
%% Version: 1.5, 15/05/2014                                         %%
%%                                                                  %%
%% Memoria del Proyecto Fin de Carrera                              %%
%% m2t/Sumario                                                      %%
%%==================================================================%%

Esta sección analiza el proceso de creación del generador de código. Para crear este generador de código se utiliza el lenguaje Epsilon Generation Language (EGL), como se comentaba en el capitulo 2 es un lenguaje utilizado para la generación de código basado en la transformación de modelos, el lenguaje a generar es Cassandra Query Language (CQL) este lenguaje de consultas es muy similar a SQL, sin embargo existen pequeñas diferencias que se han citado a lo largo del proyecto por ejemplo: la definición de claves, tipos de dato etc.
En la figura~\ref{back:code:m2t} se muestra parte del código del generador de código. Esta sección de código muestra código EGL. En primer lugar se realiza la definición del keyspace para ello hay que definir el nombre del keyspace que parte del modelo transformado Cassandra y la estrategia de replicación (ver capitulo 3, sección 2).
A continuación se realiza la creación de una column family en CQL. En primer lugar se definen las columnas de la tabla. Por cada columna de la column family se obtiene el nombre de la columna y se define el tipo de dato (primitivo,map,set/list) junto con su nombre. El resto de código se ha omitido por razones de espacio sin embargo se detalla a continuación.
Tras la definición de la columna se define la primary key. Para la definición de la primary key hay que diferenciar si la column family es dinámica o estática. En caso de ser estática la definición sería la clásica: PRIMARY KEY(ColumnaClave).
En el caso de tratarse de una column family dinámica la construcción modelo-código es distinta, la más frecuente es la siguiente: PRIMARY KEY(partitioning key, clustering key\_1 ... clustering key\_n)
Sin embargo hay que tener en cuenta que en la construcción también es posible tener una partition key compuesta, es decir, una partition key formada por varias columnas, para ello se utilizan paréntesis y así delimitamos el conjunto de partición. Quedando una posible definición de la primary key de la siguiente manera: PRIMARY KEY((partitioning key\_1, ... partitioning key\_n), clustering key\_1 ... clustering key\_n). Este proceso se repite por cada column family del modelo.

\begin{figure}[!tb]
\begin{center}
\begin{footnotesize}
\begin{verbatim}
--------------------------------------------------------
DROP KEYSPACE [%=keyspace.name%];
CREATE KEYSPACE [%=keyspace.name%]
WITH replication = {'class':'[%=keyspace.replicaPlacementStrategy%]', 'replication_factor':[%=keyspace.replicationFactor%]};

USE [%=keyspace.name%];

[% for (cf in keyspace.columnFamilies){ tableKey="";%]
CREATE TABLE [%=cf.name%](
	[% for (cols in cf.columns){ //este for define cada grupo de columnas
		s=cols.name.toString();
		for (c in cols.type){
		
			if (c.isTypeOf(PrimitiveType))  //definicion del tipo primitivo
				s=s+" "+c.kind.toString();
				
			if (c.isTypeOf(MapType)) //definicion del tipo map
				s=s+" Map"+"<"+c.keyType.toString()+","+c.baseType.toString()+">";
				
 			if(c.isTypeOf(CollectionType)) //definicion del tipo set o list
				s=s+" "+c.kind.toString()+"<"+c.keyType.toString()+">";
			
		}
);
[%}%]
--------------------------------------------------------
\end{verbatim}
\end{footnotesize}
\end{center}
\caption{Regla de transformación XX}
\label{back:code:m2t}
\end{figure} 