%%==========================================================================%%
%% Author : Sañudo Olmedo, Ignacio                                          %%
%% Author : Sánchez Barreiro, Pablo                                         %%
%% Version: 1.2, 21/04/2014                                                 %%
%%                                                                          %%
%% Memoria del Proyecto Fin de Carrera                                      %%
%% M2M/Caso de estudio                                                      %%
%%==========================================================================%%

Como se explicaba en el capítulo 2 (sección "Caso de estudio"), el objetivo consiste en la creación de un generador de código de una versión simplificada de Twitter llamada Twissandra.
En esta sección se reproducirán los procesos M2M y M2T en el siguiente capítulo, todo esto bajo el proceso de desarrollo dirigido por modelos. Esta sección está dedicada a describir la transformación del modelo UML de Twissandra a un modelo Cassandra, para ello partimos del modelo UML de la figura~\ref{back:fig:twissandra}. Una vez establecidas las reglas de transformación entre modelos podemos realizar la generación del código aunque esto se analizará en el siguiente capítulo.

En primer lugar, por cada paquete estereotipado como <<dataModel>>, se crea un nuevo keyspace. El nombre del keyspace será el nombre que se ha definido el modelo de datos UML. Los atributos restantes de las meta-clases del keyspace se establecen en sus valores definidos por defecto en el modelo UML. A continuación, todos los elementos correspondientes de ese paquete se procesan.

A continuación se realiza un marcado del atributo username de la clase User como clave, ya que el parámetro isID del modelo UML está marcado como true. En el caso de las clases FollowingRelationship y la clase Tweet al no tener un atributo marcado como clave generamos dos columnas clave automáticamente para cada clase, llamadas FollowingRelationship\_id y tweet\_id respectivamente.
La clase User del modelo UML es transformada en una column family llamada User. Una vez procesadas las clases UML y transformarlas a su correspondiente column family se proceden a transformar los atributos y asociaciones. De manera similar para aquellos atributos del modelo UML cuya multiplicidad sea igual a uno se realiza una transformación simple, por ejemplo el atributo username y password se transforman en dos columnas Cassandra, ambas del tipo text. Estas columnas están contenidas en la column family User. De la misma forma se transforman los atributos body y time de la clase Tweet y el atributo timestamp de la clase FollowingRelationship.
En el caso del atributo del modelo UML email cuya multiplicidad es mayor de uno y tiene las propiedades isUnique establecida en false y la propiedad isOrdered establecida en false (en el modelo no se puede apreciar pero está configurado así en el modelo UML), se transforma este atributo en una colección de tipo set llamada email cuyo tipo primitivo será text, esta colección estará dentro de la column family User.

En cuanto a las asociaciaciones recordamos que tenemos dos tipos, las de multiplicidad igual a uno y las de multiplicidad mayor de uno. Para la asociación de la clase User cuya multiplicidad es igual uno, se crea una nueva columna llamada user\_username (recordemos que username es la clave de la column family user) y esta columna es añadida a la column family Tweet. Para las asociaciones de multiplicidad mayor de uno, por ejemplo la asociación llamada userline se crea una dynamic column family llamada User\_userline. A continuación una columna llamada user\_username de tipo text es añadida a esta column family. Después una columna llamada tweet\_id de tipo uuid es añadida (el atributo tweet\_id fue creado en la column family tweet al no tener clave). Las columnas user\_username y tweet\_id son designadas como primary key, la columna user\_username será la partition key y la columna tweet\_id será la cluster key.


