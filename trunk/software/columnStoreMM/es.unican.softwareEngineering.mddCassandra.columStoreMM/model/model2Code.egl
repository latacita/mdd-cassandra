[%
	var keyspace: KeySpace := KeySpace.allInstances().at(0);
	var s: String;
	var tableKey:String;
	var crk:String;
	
%]
DROP KEYSPACE [%=keyspace.name%]; 
CREATE KEYSPACE [%=keyspace.name%]
WITH replication = {'class':'[%=keyspace.replicaPlacementStrategy%]', 'replication_factor':[%=keyspace.replicationFactor%]};

USE [%=keyspace.name%];


[% for (cf in keyspace.columnFamilies){ tableKey="";%]
CREATE TABLE [%=cf.name%](
	[% for (cols in cf.columns){ //este for define cada grupo de columnas
		s=cols.name.toString();
		for (c in cols.type){ 
		
			if (c.isTypeOf(PrimitiveType))  //definicion del tipo primitivo
				s=s+" "+c.kind.toString();
				
			if (c.isTypeOf(MapType)) //definicion del tipo map
				s=s+" Map"+"<"+c.keyType.toString()+","+c.baseType.toString()+">";  
				
 			if(c.isTypeOf(CollectionType)) //definicion del tipo set o list
				s=s+" "+c.kind.toString()+"<"+c.keyType.toString()+">"; 
			
		} 
	    s=s+",";%]
       [%=s%]
       [%}%]
       PRIMARY KEY([%if (cf.isTypeOf(DynamicColumnFamily)){ //en caso de ser dinamic column family primero almacenamos la partition key
       					tableKey="("; //abrimos el parentesis de la partition key
       					var clusteringKeys:List;
						for (ck in cf.partitionKey) {
		   					 tableKey=tableKey+ck.name;
		   					 clusteringKeys.add(ck.name);
		   					 if (hasMore)
								tableKey=tableKey+","; 
						 }
						 tableKey=tableKey+")"; //cerramos el parentesis de la partition key
						 //guardamos el resto de las columnKey cuidado no incluir las partition dentro
						 for (pk in cf.primaryKey) {
						    if(not clusteringKeys.includes(pk.name))
						    	tableKey=tableKey+","+pk.name;
						}	
					}
					else{ //column family estatica simplemente se añaden las primaryKey de forma estandar
						for (pk in cf.primaryKey) {
			   				tableKey=tableKey+pk.name;
			   				if (hasMore)
								tableKey=tableKey+","; 
						}	
					}
     
					%][%=tableKey%][%tableKey="";%])
);

[%}%]

